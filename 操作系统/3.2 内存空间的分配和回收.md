# 一、连续分配管理方式

![image-20210627201030926](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210627201030926.png)

连续分配：为用户进程分配的必须是一个连续的内存空间。



## 1.1 单一连续分配

在单一连续分配方式中，内存分为：（1）系统区（2）用户区。

- 系统区通常位于内存的**低地址**部分，用于存放操作系统相关数据；
- 用户区用于存放用户进程相关数据。

在单一连续分配方式中，内存中**只能有一道用户程序**，用户程序独占整个用户区空间。



**优点**：

- 实现**简单**；
- **无外部碎片**；
- 可以采用**覆盖**技术扩充内存；
- 不一定需要采用内存保护。

**缺点**：

- 只能用于单用户，单任务的操作系统中；
- **有内部碎片**；ps：分配给某些进程的内存区域中，如果有些部分没有用上，就是内部碎片。
- 存储器利用率极低。

## 1.2 固定分区分配

20世纪60年代出现了支持多道程序的系统，为了能够在内存汇总装入多道程序，且这些程序之间又不会干扰：

- 将整个用户空间**划分为若干个固定大小的分区**，在每个分区中只装入一道作业。
- 形成了最早的、最简单的一种可运行多道程序的内存管理方式。

固定分区分配：（1）**分区大小相等**（2）**分区大小不等**

- 分区大小相等：缺乏灵活性，但是很适合用于同一台计算机控制多个相同对象的场合。
- 分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分。



## 操作

操作系统需要建立一个数据结构——**分区说明表**，来实现各个分区的分配和回收。

每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的**大小、起始地址、状态**。

| 分区号 | 大小（MB） | 起始地址 |  状态  |
| :----: | :--------: | :------: | :----: |
|   1    |     2      |    8     | 已分配 |
|   2    |     8      |    10    | 未分配 |
|   3    |     4      |    18    | 未分配 |

当某用户程序要装入内存时，由操作系统内核程序根据用户大小**检索**该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。



**优点**：

- 实现简单；
- **无外部碎片**

**缺点**：

- 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖计数来解决，但这又会降低性能；
- **会产生内部碎片**，内存利用率低。

## 1.3 动态分区分配

**动态分区分配**又称为**可变分区分配**：这种分配方式**不会预先划分内存分区**，而是在进程装入内存时，根据**进程的大小动态地建立分区**，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目时可变的。

### 1.3.1 数据结构

（1）空闲分区表（2）空闲分区链

空闲分区表：每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息。

![image-20210627205106088](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210627205106088.png)

空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息。

![image-20210627205232914](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210627205232914.png)



### 1.3.2 动态分区分配

把一个新作业装入内存时，须按照一定的**动态分区分配算法**，从空闲分区表中选出一个分区分配给该作业。

|   算法   |                        算法思想                        |     分区排序顺序     |                             优点                             |                             缺点                             |
| :------: | :----------------------------------------------------: | :------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 首次适应 |                  从头到尾找适合的分区                  | **地址**递增次序排列 | 综合起来**性能最好**。**算法开销小**，回收分区后不需要对空闲分区重新排序。 |                                                              |
| 最佳适应 |        优先**使用更小的分区**，以保留更多大分区        | **容量**递增次序排列 |           有更多的大分区留下来，更能满足大进程需求           | 会产生很多很小的、难以利用的碎片；**算法开销大**，回收分区后可能需要对空闲分区队列重新排序 |
| 最坏适应 |  优先**使用更大的分区**，防止产生太小的不可能用的碎片  | **容量**递减次序排列 |                   可以减少难以利用的小碎片                   | 大分区容易被用完，不利于大进程；**算法开销大**，回收分区后可能需要对空闲分区队列重新排序 |
| 邻近适应 | 从首次适应演变而来，每次从**上次查找结束位置**开始查找 | **地址**递增次序排列 | 不用每次都从低地址的小分区开始检索。**算法开销小**，回收分区后不需要对空闲分区重新排序。 |                 会使高地址的大分区也被用完。                 |



### 1.3.3 如何回收

（1）回收区的前面或后面有一个相邻的空间分区：两个相邻的空闲分区合并在一起。

（2）回收区的前、后各有一个相邻的空闲分区：三个分区合并在一起

（3）回收区的前、后都没有相邻的空闲分区：新增一个表项



### 1.3.4 特点

**内部碎片**：分配给某进程的内存区域中，有些部分没有用上。

**外部碎片**：内存中的某些空闲分区由于太小而难以利用。（有些内存区太小而无法分配给进程）



动态分区分配：没有内部碎片，但是有外部碎片。

而单一连续分配和固定分区分配都是：有内部碎片，没有外部碎片，与动态分区分配正好相反。



当然，可以通过**紧凑**（**拼凑**，Compaction）技术来解决外部碎片。