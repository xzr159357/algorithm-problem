# 1.指针和引用

- 指针是一个变量，变量存储（的内容）的是一个地址；而引用是某个变量的别名，实质上和原变量是同一个东西。指针和引用存放的都是**被指向对象的地址**，引用必须在定义的同时进行初始化。
- 引用和指针，在内存中都占用**4个字节**（32bit）的存储空间。在底层，引用变量由指针按照**指针常量**的方式实现。引用变量的地址由编译器支配，程序员无法直接对它操作。
- 指针在初始化后可以**任意改变其指向**，而引用在初始化后不可在改变其指向。
- sizeof引用得到的是**引用所指向变量**的大小；sizeof指针得到的是**指针本身的大小**。
- 指针可以多级(int** p)，引用只有一级。**ps**：注意区别C++11的右值引用。
- 指针变量（p），&p得到的是**指针变量自身**的地址；而引用&则是得到的是**引用指向变量**的地址。
- 指针（p）的自增（++）是自增内存空间，根据指向对象的类型修改p的大小；而引用则是增加被引用对象的值。





## 2. 函数指针和指针函数

函数指针是指针，指向一个函数的入口地址；指针函数是函数，返回值是指针。



## 指针函数

```cpp
int* funTest(int a[])
{
    return a;
}

int main()
{
    int arr[5] = { 1, 2, 3, 4, 5 };
    int* p = funTest(arr);
    for (int i = 0; i < 5; i++)
    {
        cout << p[i] << endl;
    }
    
}
```

定义了一个返回值为`int*`，输入参数为`a[]`的指针函数，调用该函数**返回数组a的首地址**。



## 函数指针

```cpp
int add(int x, int y)//加
{
    return x + y;
}

int sub(int x, int y)//减
{
    return x - y;
}

typedef int (*pFun)(int, int);
int main()
{
    int (*fun)(int, int);
    fun = add;//指向add函数，注意：fun = add 和 fun = &add一致，都是指向了函数的入口地址
    cout << fun(2, 1) << endl;
    fun = sub;
    cout << fun(2, 1) << endl;
    pFun fp;
    fp = add;
    cout << fp(2, 3) << endl;

    return 0;
}
```

函数指针，本质上是指针，只不过用来指向函数的地址，可以替代函数，并可切换指向，指向不同的函数。

注意，定义函数指针时，因为`*`的优先级较小，所以需加括号，如：`void (*pfun)()`就定义了一个返回值为空、参数列表为空的函数指针，可以指向相同格式的函数。

函数指针可以有两种定义方式，两者用法一致：

```cpp
//1.
int (*fun)(int, int);
//2.
typedef int (*pFun)(int, int);
pFun fun;
```



## 3. C/C++ volatile关键字

从英文翻译中文意思就是：**易变的、不稳定的**。所以，一个变量在加了volatile修饰后，要求**编译器禁止**对volatile变量进行优化，在每个变量赋值时需显式地从寄存器拷贝。在**嵌入式**编程中比较多用到，因为可能发生中断修改了寄存器的值或一段汇编代码修改了值而不让编译器知道，这时候就要加上volatile。



注意，在C++中volatile与并发编程有关是个错误！原因可能是java中的volatile和C++是不一样的。

参考这篇博客：[C++volatile的误会](https://zhuanlan.zhihu.com/p/33074506)



# 4. 易混淆的指针概念

```cpp
int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
```

- `int *p[10]`是指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。
- `int (*p)[10]`表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。
- `int *p(int)`是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。
- `int (*p)(int)`是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。



## 5. 虚函数表和虚函数指针

- 当一个类在实现的时候，如果**存在一个或以上的虚函数**时，那么这个类便会包含一张虚函数表。而当一个子类**继承并重写**了基类的虚函数时，它也会有自己的一张虚函数表。
- **虚函数表**存储虚函数的地址，即虚函数表的元素是指向**类成员函数的指针**。简单来说，虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。
- 而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即**大小是在编译时期确定**的。
- 虚函数表每个类只有一个，只属于类而不属于对象；而虚函数指针每个对象都有且只有一个，`*__vptr`。虚函数指针自动地指向虚表中对应的位置，找到相应的成员函数。



# 6. new / delete 和 malloc / free 的区别与联系



## 相同点

new / malloc都是动态内存的开辟，在堆区开启空间；而delete / free都是动态内存的释放。



## 区别

- new / delete是C++的关键字，是C++运算符；而后者C/C++标准库函数，头文件`#include <stdlib.h>`
- new是**类型安全**的；malloc不是类型安全的，malloc的返回值是`void*`，这时候我们用一种类型指针接收，但是malloc开辟的空间可能大于设定的类型，理论上会出错但是使用malloc编译器不会出错，而使用new编译器会报错。
- new会调用构造函数，delete会调用析构函数；malloc和free并没有此功能。



## new和delete的实现机制

- new的实现过程是：首先调用名为**operator new**的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针。
- delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为**operator delete**的标准库函数释放该对象所用内存。





## delete 和 delete []

- delete 释放new分配的单个对象指针指向的内存
- delete[] 释放new分配的对象**数组**指针指向的内存
