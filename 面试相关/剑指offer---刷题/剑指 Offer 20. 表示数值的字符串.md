# 题目：剑指 Offer 20. 表示数值的字符串
**难度**： 中等

**题目**：

请请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。



**数值**（按顺序）可以分成以下几个部分：

1. 若干空格

2. 一个 小数 或者 整数

3. （可选）一个 'e' 或 'E' ，后面跟着一个 整数

4. 若干空格

   

**小数**（按顺序）可以分成以下几个部分：

1. （可选）一个符号字符（'+' 或 '-'）
2. 下述格式之一：
   1. 至少一位数字，后面跟着一个点 '.'
   2. 至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字
   3. 一个点 '.' ，后面跟着至少一位数字

**整数**（按顺序）可以分成以下几个部分：

1. （可选）一个符号字符（'+' 或 '-'）

2. 至少一位数字

   

部分**数值**列举如下：

- ["+100", "5e2", "-123", "3.1416", "-1E-16", "0123"]

部分非**数值**列举如下：

- ["12e", "1a3.14", "1.2.3", "+-5", "12e+5.4"]



## 示例 1：

```
输入：s = "0"
输出：true
```

## 示例 2：

```
输入：s = "e"
输出：false
```

## 示例 3：

```
输入：s = "."
输出：false
```

## 示例 4：

```
输入：s = "    .1  "
输出：true
```





## 说明：

- `1 <= s.length <= 20`
- `s` 仅含英文字母（大写和小写），数字（`0-9`），加号 `'+'` ，减号 `'-'` ，空格 `' '`或者点 `'.'` 。



来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
<br>
<br>

# 解题思路

- 官方的题解是利用：确定有限状态自动机，利用[初始状态]和[接收状态]的切换求解，十分复杂。

- 而我参考一些大佬的代码，以及一开始的思路，还是使用朴素法，枚举每个可能的情况，判断输入字符类型，多次尝试得出，定义4个标志位：hasNum（数字匹配）、hasSign（符号匹配）、hasDot（点匹配）、hasE（e匹配）。具体思路如下：

  - 清除开头的空格
  - 连续判断数字，hasNum = true
  - E或e：
    - 如果之前已经有E，hasE = true，错误，退出匹配
    - 如果之前无数字，hasNum = false，错误。退出匹配。因为e和E之前需要一个**小数**或者整数。
    - hasE = true，并且之后又自成体系，可以符号，需重新判断数字，点不干扰后面的判断。所以，hasNum = hasSign = hasDot = false。
  - '+' 或 '-'：
    - 之前不可有符号，hasSign = true，错误，退出匹配
    - 之前不可有数字，hasNum = true，错误并退出匹配
    - 之前不可有点，hasDot = true，错误并退出匹配
    - hasSign = true
  - 点：
    - 之前不可有点，hasDot = true，错误并退出匹配
    - 之前不可有E，hasE = true，错误并退出匹配
    - hasE = true
  - 空格：
    - 如果该空格即之后都是空格，那么是正确；如果该空格之后还有除空格之外的元素，是错误的。所以这时候不可直接错误，break退出循环即可，后面有判断末尾空格的代码。
  - 其他：
    - 出现其他字符，必然是错误的，错误并退出匹配。

  其实，这些状态的转换，需要对数值是否正确有十分深刻的理解。当然，之前有个**最关键**的地方：就是判断`e`或`E`时，将hasNum = hasSign = hasDot = false的操作。因为遇到科学计数时，（1）后面需要数值，所以清除hasNum;（2）后面可以有hasSign，所以清除hasSign;（3）后面不可有点，不管之前是否有点都需要将点的标志清除避免妨碍后面判断（否则不知道改点是E之前的点还是后面的点），所以清除hasDot。

# 解题代码


```cpp
class Solution {
public:
    bool isNumber(string s) {

        bool hasNum = false, hasE = false, hasSign = false, hasDot = false;
        int n = s.size();
        int i = 0;//在s的索引，即位置
        //除去开头部分的空格
        while (i < n && s[i] == ' ') i++;

        //主题部分处理
        while (i < n)
        {
            //连续处理数字，因为数字可以连续
            while (i < n && s[i] >= '0' && s[i] <= '9')
            {
                i++;
                hasNum = true;
            }
            if (i == n) //搜索完毕
            {
                break;
            }

            if (s[i] == 'e' || s[i] == 'E')//在其之前不可有e，且前面需一个小数or整数
            {
                if (hasE || !hasNum)
                {
                    return false;
                }
                hasE = true;
                //在有e后，后面的符号、数字可重新加入，点也要去掉防止后面出现点干扰后面的
                hasSign = hasNum = hasDot = false;
            }
            else if (s[i] == '+' || s[i] == '-')
            {
                if (hasSign || hasNum || hasDot)    //已经有符号、数字、点，错误。如果前面有e，会删除标志，不影响
                {
                    return false;
                }
                hasSign = true;
            }
            else if (s[i] == '.')
            {
                if (hasDot || hasE) //已有点不行，E后不可有.,E前的.在遇到E时已被清除标志
                {
                    return false;
                }
                hasDot = true;
            }
            else if (s[i] == ' ')//无法判断空格后是否还有数字，返回;
            {
                break;
            }
            else //其他情况皆错误
            {
                return false;
            }
            i++;
        }

        //除去末尾部分的空格
        while (i < n && s[i] == ' ') i++;

        return i == n && hasNum;
    }
};
```