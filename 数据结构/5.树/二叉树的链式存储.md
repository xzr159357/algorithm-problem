# 一、关键

- 需要一个左指针和右指针
- 层序遍历需要队列辅助。每访问一个队头元素，将该元素的左指针和右指针加入其中（如果有的话）。
- 寻找前驱，其实和普通遍历方式一致，不过visit函数修改，变为判断是否找到当前元素，是则返回前驱；否则继续寻找。这里采用全局变量的方式，返回final，pre是前驱，p是需要找的元素。





# 二、代码

## 2.1 结构体定义

```C++
typedef int ElemType;
typedef struct BitNode
{
    ElemType data;
    struct BitNode* lchild, * rchild;
}BitNode, *BiTree;
```

## 2.2 先序、中序、后序、层序遍历

```C++
void visit(BitNode* node)
{
    cout << node->data << endl;
}

void PreOrder(BiTree T)//先序遍历
{
    if (T)
    {
        visit(T);
        PreOrder(T->lchild);
        PreOrder(T->rchild);
    }
}

void InOrder(BiTree T)//中序遍历
{
    if (T)
    { 
        PreOrder(T->lchild);
        visit(T);
        PreOrder(T->rchild);
    }
}

void PostOrder(BiTree T)//后序遍历
{
    if (T)
    {
        PreOrder(T->lchild);
        PreOrder(T->rchild);
        visit(T);
    }
}

deque<BitNode*> que;
void LevelOrder(BiTree T)//层序遍历，使用队列辅助
{
    if(T)
        que.push_back(T);
    while (!que.empty())
    {
        T = *que.begin();
        visit(*que.begin());
        que.pop_front();
        if (T->lchild)
            que.push_back(T->lchild);
        if (T->rchild)
            que.push_back(T->rchild);
    }
    
}
```

## 2.3 土方法寻找前驱

```C++
//辅助全局变量，查找节点的前驱
BitNode* p; //寻找的节点
BitNode* pre = NULL;
BitNode* final = NULL;  //返回的节点

void visitPre(BitNode* q)
{
    if (q == p) //找到了，p是需要找的节点
        final = pre;
    else
        pre = q;

}

void findPre(BiTree T)//找中序前驱
{
    if (T)
    {
        findPre(T->lchild);
        visitPre(T);
        findPre(T->rchild);
    }
}
```



## 2.4 完整代码

```c++
#include <iostream>
using namespace std;
#include <deque>

typedef int ElemType;
typedef struct BitNode
{
    ElemType data;
    struct BitNode* lchild, * rchild;
}BitNode, *BiTree;

void Insert(BitNode*& node, ElemType value)//插入元素
{
    BitNode* temp = (BitNode*)malloc(sizeof(BitNode));
    if (!temp)
        return;
    temp->data = value;
    temp->lchild = NULL;
    temp->rchild = NULL;
    node = temp;
}

void visit(BitNode* node)
{
    cout << node->data << endl;
}

void PreOrder(BiTree T)//先序遍历
{
    if (T)
    {
        visit(T);
        PreOrder(T->lchild);
        PreOrder(T->rchild);
    }
}

void InOrder(BiTree T)//中序遍历
{
    if (T)
    { 
        PreOrder(T->lchild);
        visit(T);
        PreOrder(T->rchild);
    }
}

void PostOrder(BiTree T)//后序遍历
{
    if (T)
    {
        PreOrder(T->lchild);
        PreOrder(T->rchild);
        visit(T);
    }
}

deque<BitNode*> que;
void LevelOrder(BiTree T)//层序遍历，使用队列辅助
{
    if(T)
        que.push_back(T);
    while (!que.empty())
    {
        T = *que.begin();
        visit(*que.begin());
        que.pop_front();
        if (T->lchild)
            que.push_back(T->lchild);
        if (T->rchild)
            que.push_back(T->rchild);
    }
    
}


int main()
{
    //二叉树的链式存储
    BiTree root = NULL;
    root = (BiTree)malloc(sizeof(BitNode));
    if (!root)
        return 0;
    root->data = 1;
    root->lchild = NULL;
    root->rchild = NULL;
    Insert(root->lchild, 2);
    Insert(root->rchild, 3);
    Insert(root->lchild->lchild, 4);
    Insert(root->lchild->rchild, 5);
    Insert(root->rchild->lchild, 6);
    Insert(root->lchild->lchild->lchild, 7);
    LevelOrder(root);

    return 0;
    
}
```

