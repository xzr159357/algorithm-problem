# 关键

- 需要一个左指针和右指针
- 层序遍历需要队列辅助。每访问一个队头元素，将该元素的左指针和右指针加入其中（如果有的话）。





# 代码

```c++
#include <iostream>
using namespace std;
#include <deque>

typedef int ElemType;
typedef struct BitNode
{
    ElemType data;
    struct BitNode* lchild, * rchild;
}BitNode, *BiTree;

void Insert(BitNode*& node, ElemType value)//插入元素
{
    BitNode* temp = (BitNode*)malloc(sizeof(BitNode));
    if (!temp)
        return;
    temp->data = value;
    temp->lchild = NULL;
    temp->rchild = NULL;
    node = temp;
}

void visit(BitNode* node)
{
    cout << node->data << endl;
}

void PreOrder(BiTree T)//先序遍历
{
    if (T)
    {
        visit(T);
        PreOrder(T->lchild);
        PreOrder(T->rchild);
    }
}

void InOrder(BiTree T)//中序遍历
{
    if (T)
    { 
        PreOrder(T->lchild);
        visit(T);
        PreOrder(T->rchild);
    }
}

void PostOrder(BiTree T)//后序遍历
{
    if (T)
    {
        PreOrder(T->lchild);
        PreOrder(T->rchild);
        visit(T);
    }
}

deque<BitNode*> que;
void LevelOrder(BiTree T)//层序遍历，使用队列辅助
{
    if(T)
        que.push_back(T);
    while (!que.empty())
    {
        T = *que.begin();
        visit(*que.begin());
        que.pop_front();
        if (T->lchild)
            que.push_back(T->lchild);
        if (T->rchild)
            que.push_back(T->rchild);
    }
    
}


int main()
{
    //二叉树的链式存储
    BiTree root = NULL;
    root = (BiTree)malloc(sizeof(BitNode));
    if (!root)
        return 0;
    root->data = 1;
    root->lchild = NULL;
    root->rchild = NULL;
    Insert(root->lchild, 2);
    Insert(root->rchild, 3);
    Insert(root->lchild->lchild, 4);
    Insert(root->lchild->rchild, 5);
    Insert(root->rchild->lchild, 6);
    Insert(root->lchild->lchild->lchild, 7);
    LevelOrder(root);

    return 0;
    
}
```

